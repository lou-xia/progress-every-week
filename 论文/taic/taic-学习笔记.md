## 设计思路：
1. 原则一：严格划分执行流之间的边界，把执行流抽象成任务，建立基于执行流的任务模型。  
   - 任务建模为 $𝑇(𝑃_𝑖, 𝐿_𝑗 , 𝑆_𝑘)$，P、L、S分别表示进程地址空间、特权级、堆栈保存的执行流函数调用状态
   - 任务切换建模为三元组 $[prev] -> [next] : \{condition\}$
   - S 一定改变，P、L 改变分四种情况。
2. 原则二：将调度实体的粒度对齐到基于执行流的任务模型上。
    - 设计硬件化的任务调度器，需要感知任务状态信息，通过：
      - 分层复合型任务标识：$(𝑂(𝑊_𝑖), 𝑃(𝑊_𝑗), 𝑇(𝑊_𝑘))$
      - 软硬协同的任务状态维护方法：在硬件内维护每个 CPU 的当前任务标识、就绪队列、阻塞队列，维护偏序关系，实现调度器功能；在软件部分通过写硬件端口实现任务状态的切换。
3. 原则三：合理划分软件与硬件的边界和协作关系，简化任务之间的交互关系。
   - 通过硬件实现中断，进而实现进程间通信，以通道的形式建立连接。

## 一些疑问：
1. 统一调度与分级调度相比，优势有哪些？除了能选择优先级更高的执行流外，有没有在性能方面的其他优势？阻塞操作上，同步改异步，线程为单位改成协程为单位。线程与协程同级参与调度，不会因线程阻塞而阻塞其他协程。在异步任务多时有优势
2. 在这种设计中，是否会导致地址空间切换过于频繁，影响性能？调度算法层面改进，同进程任务相邻