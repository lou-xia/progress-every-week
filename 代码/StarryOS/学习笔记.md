# 学习笔记

沿着启动流程记录

## 启动流程

### arceos 启动

1. 在`arceos/doc/build.md`里提到，启动从`_start`开始，先设置了启动栈基址和栈顶，然后初始化了启动页的页表并开启了 mmu，并相应的把`sp`的值也改成虚拟地址的值（这里感觉像是和 Linux 一样，虚拟地址的高地址部分是内核空间），最后跳转到`axplat::call_main`。这部分的具体代码没有细看，只看到了文档里的示例的代码。
2. `call_main`具体实现不清楚，没有细看，跟启动时选择的架构有关。总之`call_main`跳转到了`axruntime::rust_main`。
3. `rust_main`先初始化 percpu（这里的percpu是什么？我的理解应该跟 Linux 的 percpu 机制类似，每个 cpu 都有自己的变量副本），然后是`init_early`（应该是用来初始化平台相关的参数）。然后打印 LOGO（好帅的 logo）和一些启动参数
4. 初始化日志、物理内存（通过一个 vector 实现，过程中初始化了一些标志等信息）、全局内存分配器（把最大的区域当作分配器所在的内存区域，之后再其他区域添加进去）、线程调用栈
5. 初始化虚拟内存、`init_later`（与上面的`init_early`类似？）、初始化调度器、文件系统、网络等设备
6. 初始化中断（注册时钟中断，然后开启中断）
7. 等待所有 cpu 都初始化完成后，进入`main`函数，这里的`main`函数是用户程序（对 arceos 而言）的入口，即 starry-os 的`main`函数。

总结：arceos 启动过程是最基础的与硬件（内存、cpu、磁盘等）交互和初始化的过程。我感觉已经较为全面了。  
很多代码实现的细节我没有细看，但按照注释的解释应该是比较清楚的。  
其中，由于每个 cpu 都要经历初始化，有些地方（比如`axhal::mem::init()`）不需要重复执行，因此其中都使用了`init_once`。

### 进入 Starry-OS

1. 从`/arceos/axruntime`中的`rust_main`进入到`/src/main.rs`中的`main`函数。这个过程究竟发生了什么？我尝试了把`/src/main.rs`中改成`main1`，会出现编译报错，但是两边都改成`main1`又能正常运行。我猜测跟动态链接有关。
2. 进入`main`后，先初始化`starry_api`，包括虚拟文件系统、时钟计数、时钟线程。然后进入`entry::run_initproc`
3. 在`entry::run_initproc`中，创建用户程序空间，然后从文件系统中找到`/bin/sh`文件，并打开文件，得到入口虚拟地址和用户栈栈顶地址，并创建用户程序入口上下文
4. 从上下文创建任务并设置用户页表的`root`，然后新建`pid`、进程和线程，设置`N_TTY`等信息，然后创建进程相关数据。
5. 设置进程的`stdio`，然后根据`pid`和进程相关数据创建线程，设置任务的扩展数据
6. 将当前任务添加到运行队列，然后添加到任务表、进程表、进程组表、会话表。
7. 最后调用任务的`join`函数。

我认为，这里的任务才是调度的对象，保留了任务调度中最核心的数据，进程和线程对象中只保留了扩展数据，通过`pid`关联。

8. 在`join`中，将任务转换为协程，再通过`block_on`等待结果

