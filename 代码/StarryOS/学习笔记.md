# 学习笔记

沿着启动流程记录

## 启动流程

### arceos 启动

1. 在`arceos/doc/build.md`里提到，启动从`_start`开始，先设置了启动栈基址和栈顶，然后初始化了启动页的页表并开启了 mmu，并相应的把`sp`的值也改成虚拟地址的值（这里感觉像是和 Linux 一样，虚拟地址的高地址部分是内核空间），最后跳转到`axplat::call_main`。这部分的具体代码没有细看，只看到了文档里的示例的代码。
2. `call_main`具体实现不清楚，没有细看，跟启动时选择的架构有关。总之`call_main`跳转到了`axruntime::rust_main`。
3. `rust_main`先初始化 percpu（这里的percpu是什么？我的理解应该跟 Linux 的 percpu 机制类似，每个 cpu 都有自己的变量副本），然后是`init_early`（应该是用来初始化平台相关的参数）。然后打印 LOGO（好帅的 logo）和一些启动参数
4. 初始化日志、物理内存（通过一个 vector 实现，过程中初始化了一些标志等信息）、全局内存分配器（把最大的区域当作分配器所在的内存区域，之后再其他区域添加进去）、线程调用栈
5. 初始化虚拟内存、`init_later`（与上面的`init_early`类似？）
6. 初始化调度器：在`init_schedler`中，先保存当前 CPU 数量到`CPU_NUM`中，再调用`run_queue::init()`
7. 在`run_queue::init`中，先创建`idle_task`对象，然后设置其 cpu 为当前 cpu，再让 percpu 的`IDLE_TASK`初始化为`idle_task`。在`idle_task`中，重复`yield_now()`和等待 irq。
8. 继续创建`main_task`，并设置其状态为`Running`，并用它初始化`CurrentTask`。我认为`main_task`在这个阶段代表的是初始化任务。之后初始化 percpu 的任务队列，并把这个任务队列添加到所有队列的 list 中。最后返回`rust_main`
9. 初始化文件系统、网络等设备
10. 初始化中断（注册时钟中断，然后开启中断）
11. 等待所有 cpu 都初始化完成后，进入`main`函数，这里的`main`函数是用户程序（对 arceos 而言）的入口，即 starry-os 的`main`函数。

总结：arceos 启动过程是最基础的与硬件（内存、cpu、磁盘等）交互和初始化的过程。我感觉已经较为全面了。  
很多代码实现的细节我没有细看，但按照注释的解释应该是比较清楚的。  
其中，由于每个 cpu 都要经历初始化，有些地方（比如`axhal::mem::init()`）不需要重复执行，因此其中都使用了`init_once`。

### 进入 Starry-OS后

1. 从`/arceos/axruntime`中的`rust_main`进入到`/src/main.rs`中的`main`函数。这个过程究竟发生了什么？我尝试了把`/src/main.rs`中改成`main1`，会出现编译报错，但是两边都改成`main1`又能正常运行。我猜测跟动态链接有关。
2. 进入`main`后，先初始化`starry_api`，包括虚拟文件系统、时钟计数、时钟线程。然后进入`entry::run_initproc`
3. 在`entry::run_initproc`中，创建用户程序空间，然后从文件系统中找到`/bin/sh`文件，并打开文件，得到入口虚拟地址和用户栈栈顶地址，并创建用户程序入口上下文
4. 从上下文创建任务并设置用户页表的`root`，然后新建`pid`、进程和线程，设置`N_TTY`等信息，然后创建进程相关数据。
5. 设置进程的`stdio`，然后根据`pid`和进程相关数据创建线程，设置任务的扩展数据
6. 将当前任务添加到运行队列。其中`spawn_task()`的作用是选一个合适的 cpu 运行队列，添加进去。这之后添加到任务表、进程表、进程组表、会话表。
7. 最后调用任务的`join`函数。

我认为，这里的任务才是调度的对象，保留了任务调度中最核心的数据，进程（实际上在 arceos 中没有进程概念）和线程对象中只保留了扩展数据，通过`pid`关联。

8. 在`join`中，创建一个协程任务来查看自己的状态，在状态为`Exited`时返回，再通过`block_on`等待结果
    > Q：这里为什么要用协程呢？我尝试了这样写：
    >```rust
    >pub fn join(&self) -> i32 {
    >    // block_on(poll_fn(|cx| {
    >    //     if self.state() == TaskState::Exited {
    >    //         return Poll::Ready(self.exit_code.load(Ordering::Acquire));
    >    //     }
    >    //     self.wait_for_exit.register(cx.waker());
    >    //     Poll::Pending
    >    // }))
    >    loop {
    >        if self.state() == TaskState::Exited {
    >            return self.exit_code.load(Ordering::Acquire);
    >        } else {
    >            yield_now();
    >        }
    >    }
    >}
    >```
    > 发现也能正常运行，那么用协程有什么优势呢？
    
9. `block_on`的作用是阻塞当前线程，直到协程任务完成，然后返回结果。其中，它先把当前任务（我认为就是现在运行的任务，即上述的`main_task`）复制一份，存到一个 `waker: Arc<AxWaker>`中，再存入`core::task::Waker`里，并根据`waker`创建`cx: Context`。
10. 之后进入循环。在循环开始时存入`woke`为`false`，然后进行一次`poll`，传入`cx`，如果协程任务完成，则返回结果，否则判断`woke`是否为`false`，如果为`false`，则调用`yield_now()`，让出线程，否则调用`current_run_queue::<NoPreemptIrqSave>().blocked_resched()`。
11. 先说`blocked_resched()`，它先对当前任务做一些检查，比如`is_running`且不是`idle_task`等，然后设置状态为`Blocked`~~注释说这里还把任务放入了等待队列`waiting queue`，不过我没找到其实现~~，最后调用`self.inner.resched()`
12. 再说`yield_now()`，它调用`current_run_queue::<NoPreemptIrqSave>().yield_current()`，在其中检查当前任务是`is_running`，然后调用`put_task_with_state()`。这个函数的意义是：如果这个任务此刻正好处于我期望的状态，那么在确保没有任何 CPU 正在调度它之后，把它迁移到本 CPU 的 runqueue，并决定是否抢占当前任务；否则自旋等待其他 CPU 调度结束。之后也调用`self.inner.resched()`
13. `self.inner.resched()`中，实现了任务切换。先取出下一个任务，如果没有可以运行的则使用`idle_task`。打印调试信息后，调用`switch_to()`进行任务切换。`switch_to()`中，先设置下一任务不可抢占与运行状态，再检查是否与上一任务相同，相同则直接返回。然后设置下一任务已在 CPU 上运行，并调用 prev 和 next 线程的钩子函数。设置 percpu 的 `PREV_TASK`指针，设置当前任务为下一任务（这个过程中主动 drop 了前一任务来减少任务的引用计数），构造任务上下文并切换：`(*prev_ctx_ptr).switch_to(&*next_ctx_ptr);`。~~最后还要清除 percpu 的 `PREV_TASK`指针，这个指针的作用是什么？？？我的理解是为了告诉其他 CPU 这个任务还有用，虽然这个任务本身的信息说明已经不在运行，但这个任务还在参与切换的过程中，不能被其他 CPU 调度。~~
14. 任务上下文的切换`switch_to`中，按照 feature 切换了`tp`（线程指针）、`satp`（地址空间）、`fp_state`（~~浮点状态？是啥？~~），然后切换了其他寄存器，包括`ra`、`sp`、`s0~s11`（其实这些都是被调用者保存的寄存器）。到此为止，任务切换结束，执行第一个用户态程序`/bin/sh`

