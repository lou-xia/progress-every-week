# 学习笔记

沿着启动流程记录

## 启动流程

### arceos 启动

1. 在`arceos/doc/build.md`里提到，启动从`_start`开始，先设置了启动栈基址和栈顶，然后初始化了启动页的页表并开启了 mmu，并相应的把`sp`的值也改成虚拟地址的值（这里感觉像是和 Linux 一样，虚拟地址的高地址部分是内核空间），最后跳转到`axplat::call_main`。这部分的具体代码没有细看，只看到了文档里的示例的代码。
2. `call_main`具体实现不清楚，没有细看，跟启动时选择的架构有关。总之`call_main`跳转到了`axruntime::rust_main`。
3. `rust_main`先初始化 percpu（这里的percpu是什么？我的理解应该跟 Linux 的 percpu 机制类似，每个 cpu 都有自己的变量副本），然后是`init_early`（应该是用来初始化平台相关的参数）。然后打印 LOGO（好帅的 logo）和一些启动参数
4. 初始化日志、物理内存（通过一个 vector 实现，过程中初始化了一些标志等信息）、全局内存分配器（把最大的区域当作分配器所在的内存区域，之后再其他区域添加进去）、线程调用栈
5. 初始化虚拟内存、`init_later`（与上面的`init_early`类似？）、初始化调度器、文件系统、网络等设备
6. 初始化中断（注册时钟中断，然后开启中断）
7. 等待所有 cpu 都初始化完成后，进入`main`函数，这里的`main`函数是用户程序（对 arceos 而言）的入口，即 starry-os 的`main`函数。

总结：arceos 启动过程是最基础的与硬件（内存、cpu、磁盘等）交互和初始化的过程。我感觉已经较为全面了。  
很多代码实现的细节我没有细看，但按照注释的解释应该是比较清楚的。  
其中，由于每个 cpu 都要经历初始化，有些地方（比如`axhal::mem::init()`）不需要重复执行，因此其中都使用了`init_once`。

### 进入 Starry-OS

1. 从`/arceos/axruntime`中的`rust_main`进入到`/src/main.rs`中的`main`函数。这个过程究竟发生了什么？我尝试了把`/src/main.rs`中改成`main1`，会出现编译报错，但是两边都改成`main1`又能正常运行。我猜测跟动态链接有关。
2. 