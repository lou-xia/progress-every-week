# 学习笔记

沿着启动流程记录

## 启动流程

### arceos 启动

1. 在`arceos/doc/build.md`里提到，启动从`_start`开始，先设置了启动栈基址和栈顶，然后初始化了启动页的页表并开启了 mmu，并相应的把`sp`的值也改成虚拟地址的值（这里感觉像是和 Linux 一样，虚拟地址的高地址部分是内核空间），最后跳转到`axplat::call_main`。这部分的具体代码没有细看，只看到了文档里的示例的代码。
2. `call_main`具体实现不清楚，没有细看，跟启动时选择的架构有关。总之`call_main`跳转到了`axruntime::rust_main`。
3. `rust_main`先初始化 percpu（这里的percpu是什么？我的理解应该跟 Linux 的 percpu 机制类似，每个 cpu 都有自己的变量副本），然后是`init_early`（应该是用来初始化平台相关的参数）。然后打印 LOGO（好帅的 logo）和一些启动参数
4. 初始化日志、物理内存（通过一个 vector 实现，过程中初始化了一些标志等信息）、全局内存分配器（把最大的区域当作分配器所在的内存区域，之后再其他区域添加进去）、线程调用栈
5. 初始化虚拟内存、`init_later`（与上面的`init_early`类似？）
6. 初始化调度器：在`init_schedler`中，先保存当前 CPU 数量到`CPU_NUM`中，再调用`run_queue::init()`
7. 在`run_queue::init`中，先创建`idle_task`对象，然后设置其 cpu 为当前 cpu，再让 percpu 的`IDLE_TASK`初始化为`idle_task`。在`idle_task`中，重复`yield_now()`和等待 irq。
8. 继续创建`main_task`，并设置其状态为`Running`，并用它初始化`CurrentTask`。我认为`main_task`在这个阶段代表的是初始化任务。之后初始化 percpu 的任务队列，并把这个任务队列添加到所有队列的 list 中。最后返回`rust_main`
9. 初始化文件系统、网络等设备
10. 初始化中断（注册时钟中断，然后开启中断）
11. 等待所有 cpu 都初始化完成后，进入`main`函数，这里的`main`函数是用户程序（对 arceos 而言）的入口，即 starry-os 的`main`函数。

总结：arceos 启动过程是最基础的与硬件（内存、cpu、磁盘等）交互和初始化的过程。我感觉已经较为全面了。  
很多代码实现的细节我没有细看，但按照注释的解释应该是比较清楚的。  
其中，由于每个 cpu 都要经历初始化，有些地方（比如`axhal::mem::init()`）不需要重复执行，因此其中都使用了`init_once`。

### 进入 Starry-OS后

1. 从`/arceos/axruntime`中的`rust_main`进入到`/src/main.rs`中的`main`函数。这个过程究竟发生了什么？我尝试了把`/src/main.rs`中改成`main1`，会出现编译报错，但是两边都改成`main1`又能正常运行。我猜测跟动态链接有关。
2. 进入`main`后，先初始化`starry_api`，包括虚拟文件系统、时钟计数、时钟线程。然后进入`entry::run_initproc`
3. 在`entry::run_initproc`中，创建用户程序空间，然后从文件系统中找到`/bin/sh`文件，并打开文件，得到入口虚拟地址和用户栈栈顶地址，并创建用户程序入口上下文
4. 从上下文创建任务并设置用户页表的`root`，然后新建`pid`、进程和线程，设置`N_TTY`等信息，然后创建进程相关数据。
5. 设置进程的`stdio`，然后根据`pid`和进程相关数据创建线程，设置任务的扩展数据
6. 将当前任务添加到运行队列。其中`spawn_task()`的作用是选一个合适的 cpu 运行队列，添加进去。这之后添加到任务表、进程表、进程组表、会话表。
7. 最后调用任务的`join`函数。

我认为，这里的任务才是调度的对象，保留了任务调度中最核心的数据，进程（实际上在 arceos 中没有进程概念）和线程对象中只保留了扩展数据，通过`pid`关联。

8. 在`join`中，创建一个协程任务来查看自己的状态，在状态为`Exited`时返回，再通过`block_on`等待结果
    > Q：这里为什么要用协程呢？我尝试了这样写：
    >```rust
    >pub fn join(&self) -> i32 {
    >    // block_on(poll_fn(|cx| {
    >    //     if self.state() == TaskState::Exited {
    >    //         return Poll::Ready(self.exit_code.load(Ordering::Acquire));
    >    //     }
    >    //     self.wait_for_exit.register(cx.waker());
    >    //     Poll::Pending
    >    // }))
    >    loop {
    >        if self.state() == TaskState::Exited {
    >            return self.exit_code.load(Ordering::Acquire);
    >        } else {
    >            yield_now();
    >        }
    >    }
    >}
    >```
    > 发现也能正常运行，那么用协程有什么优势呢？
    
9. `block_on`的作用是阻塞当前线程，直到协程任务完成，然后返回结果。其中，它先把当前任务（我认为就是现在运行的任务，即上述的`main_task`）复制一份，存到一个 `waker: Arc<AxWaker>`中，再存入`core::task::Waker`里，并根据`waker`创建`cx: Context`。
10. 之后进入循环。在循环开始时存入`woke`为`false`，然后进行一次`poll`，传入`cx`，如果协程任务完成，则返回结果，否则判断`woke`是否为`false`，如果为`false`，则调用`yield_now()`，让出线程，否则调用`current_run_queue::<NoPreemptIrqSave>().blocked_resched()`。

